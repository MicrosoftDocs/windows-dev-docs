---
title: Real-time audio manipulation
author: KevinAsgari
description: Learn how to manipulate and process the chat audio captured by Game Chat 2.
ms.author: kevinasg
ms.date: 03/22/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: xbox live, xbox, games, uwp, windows 10, xbox one, game chat 2, game chat, voice communication, buffer manipulation, audio manipulation
ms.localizationpriority: low
---

# Real-time audio manipulation

Game Chat 2 (GC2) gives developers the option to insert themselves into the chat audio pipeline to inspect and manipulate the players' chat audio data. This can be useful for applying interesting audio effects to players' voices in game. GC2's audio manipulation pipeline is interfaced with through audio stream objects that can be polled for audio data. As opposed to using callbacks, this model allows developers to inspect or manipulate audio on whatever processing thread is most convenient for them.

A brief walkthrough using real-time audio manipulation is featured below, containing the following topics:

1. [Initializing the audio manipulation pipeline](#initializing-the-audio-manipulation-pipeline)
2. [Processing audio stream state changes](#processing-audio-stream-state-changes)
3. [Manipulating pre-encode chat audio](#manipulating-pre-encode-chat-audio-data)
4. [Manipulating post-decode chat audio](#manipulating-post-decode-chat-audio-data)
5. [Chat user lifetimes](#chat-user-lifetimes)

## Initializing the audio manipulation pipeline

GC2 by default will not enable real-time audio manipulation. To enable real-time audio manipulation the app must specify which form(s) of audio manipulation it would like enabled in `chat_manager::initialize()`.

Currently, the following audio manipulation forms are supported:

* `game_chat_audio_manipulation_mode_flags::none` - Disables audio manipulation. This is the default configuration. In this mode, chat audio will flow uninterrupted.
* `game_chat_audio_manipulation_mode_flags::pre_encode_stream_manipulation` - Enables pre-encode audio manipulation. In this mode, all chat audio generated by local users will be fed through the audio manipulation pipeline before it is encoded. Even if the app is only inspecting the chat audio data and not manipulating it, it is still the  app's responsibility to submit the unaltered audio buffers back to GC2 so that they can be encoded and transmitted.
* `game_chat_audio_manipulation_mode_flags::post_decode_stream_manipulation` - Enables post-decode audio manipulation. This mode is currently in development and should not be used.

## Processing audio stream state changes

GC2 provides updates to the state of audio streams through `game_chat_stream_state_change` structures. These updates store information about which stream has been updated and how it has been updated. These updates can be polled for through calls to the `chat_manager::start_processing_stream_state_changes` and `chat_manager::finish_processing_stream_state_changes` pair of methods. This pair of methods provides all of the latest, queued audio stream state updates as an array of `game_chat_stream_state_change` structure pointers. Apps should iterate over the array and handle each update appropriately. Once all available `game_chat_stream_state_change` updates have been handled, that array should be passed back to GC2 through `chat_manager::finish_processing_stream_state_changes()`. For example:

```cpp
uint32_t streamStateChangeCount;
game_chat_stream_state_change_array streamStateChanges;
chat_manager::singleton_instance().start_processing_stream_state_changes(&streamStateChangeCount, &streamStateChanges);

for (uint32_t streamStateChangeIndex = 0; streamStateChangeIndex < streamStateChangeCount; ++streamStateChangeIndex)
{
    switch (streamStateChanges[streamStateChangeIndex]->state_change_type)
    {
        case game_chat_stream_state_change_type::pre_encode_audio_stream_created:
        {
            HandlePreEncodeAudioStreamCreated(streamStateChanges[streamStateChangeIndex].preEncodeAudioStream);
            break;
        }

        case Xs::game_chat_2::game_chat_stream_state_change_type::pre_encode_audio_stream_closed:
        {
            HandlePreEncodeAudioStreamClosed(streamStateChanges[streamStateChangeIndex].preEncodeAudioStream);
            break;
        }

        ...
    }
}
chat_manager::singleton_instance().finish_processing_stream_state_changes(streamStateChanges);
```

## Manipulating pre-encode chat audio data

GC2 provides access to pre-encode chat audio data for local users through the `pre_encode_audio_stream` class.

### Stream Lifetime
When a new `pre_encode_audio_stream` instance is ready for the app to use, it will be delivered through a `game_chat_stream_state_change` structure with it's type field set to `game_chat_stream_state_change_type::pre_encode_audio_stream_created`. Once this stream state change is returned to GC2, the audio stream will become available for pre-encode audio manipulation.

When an existing `pre_encode_audio_stream` becomes unavailable to use for audio manipulation, the app will be notified through a `game_chat_stream_state_change` structure with it's type field set to `game_chat_stream_state_change_type::pre_encode_audio_stream_closed`. This is the app's opportunity to start cleaning up the resources associated with this audio stream. Once this stream state change is returned to GC2, the audio stream will become unavailable for pre-encode audio manipulation.

When a closed `pre_encode_audio_stream` has all of it's resources returned, the stream will be destroyed and the app will be notified through a `game_chat_stream_state_change` structure with it's type field set to `game_chat_stream_state_change_type::pre_encode_audio_stream_destroyed`. Any references or pointers to this stream should be cleaned up. Once this stream state change is returned to GC2, the audio stream memory will become invalid.

### Stream Users
The list of users associated with a stream can be inspected using `pre_encode_audio_stream::get_users()`.

### Audio Formats
The audio format of the buffers the app retrieves from GC2 can be inspected using `pre_encode_audio_stream::get_pre_processed_format()`. The pre-processed audio format will always be mono. The app should expect to handle data represented as 32-bit floats, 16-bit integers, and 32-bit integers.

The app must inform GC2 of the audio format of the manipulated buffers that are being submitted to it for encoding and transmission using `pre_encode_audio_stream::set_processed_format()`. Processed formats for pre-encode audio streams must meet these pre-conditions:

* The format must be mono.
* The format must be 32-bit float PCM, 32-bit integer PCM, or 16-bit integer PCM formats.
* The format's sample rate must follow pre-conditions based on it's platform. Xbox One ERA supports 8kHz, 12kHz, 16kHz, and 24kHz sample rates. UWP for Xbox One and PC supports 8kHz, 12kHz, 16kHz, 24kHz, 32kHz, 44.1kHz, and 48kHz sample rates.

### Retrieving and Submitting Audio
Apps can query pre-encode audio streams for the number of available buffers to process using `pre_encode_audio_stream::get_available_buffer_count()`. This information can be used if the app would like to delay audio processing until a minimum number of buffers are available. Only 10 buffers will be queued on each pre-encode audio stream and audio delays will introduce latency in the audio pipeline, so it's recommended that apps drain their pre-encode audio streams before they queue more than 4 buffers.

Apps can retrieve audio buffers from a pre-encode audio stream using `pre_encode_audio_stream::get_next_buffer()`. New audio buffers will be available on average, once every 40ms. Buffers returned by this method must be released to `pre_encode_audio_stream::return_buffer()` when they are done being used. A maximum of 10 queued or unreturned buffers can exist at any given time for a pre-encode audio stream. Once this limit is reached, new buffers captured from the player's audio source will be dropped until some of the outstanding buffers are returned.

Apps can submit their inspected and manipulated buffers back to GC2 for encoding and transmission using `pre_encode_audio_stream::submit_buffer()`. GC2 supports in-place and out-of-place audio manipulation, so the buffers submitted to `pre_encode_audio_stream::submit_buffer()` do not necessarily have to be the same buffers retrieved from `pre_encode_audio_stream::get_next_buffer()`. Privacy/privilege for these submitted buffers will be applied based on the users associated with this stream. Every 40ms, the next 40ms of audio from this stream will be encoded and transmitted. To prevent audio hiccups, buffers for audio that should be heard continuously should be submitted to this stream at a constant rate.

### Stream Contexts
Apps can manage custom pointer-sized context values on pre-encode audio streams using `pre_encode_audio_stream::set_custom_stream_context()` and `pre_encode_audio_stream::custom_stream_context()`. These custom stream contexts are helpful for creating mappings between GC2's audio streams and auxillary data: stream metadata, game state, etc.

### Example
Here's a simplified end-to-end sample for how to use pre-encode audio streams in one audio processing frame:

```cpp
uint32_t streamStateChangeCount;
game_chat_stream_state_change_array streamStateChanges;
chat_manager::singleton_instance().start_processing_stream_state_changes(&streamStateChangeCount, &streamStateChanges);

for (uint32_t streamStateChangeIndex = 0; streamStateChangeIndex < streamStateChangeCount; ++streamStateChangeIndex)
{
    switch (streamStateChanges[streamStateChangeIndex]->state_change_type)
    {
        case game_chat_stream_state_change_type::pre_encode_audio_stream_created:
        {
            stream->set_processed_audio_format(...);
            stream->set_custom_stream_context(...);
            HandlePreEncodeAudioStreamCreated(streamStateChanges[streamStateChangeIndex].preEncodeAudioStream);
            break;
        }

        case Xs::game_chat_2::game_chat_stream_state_change_type::pre_encode_audio_stream_closed:
        {
            HandlePreEncodeAudioStreamClosed(streamStateChanges[streamStateChangeIndex].preEncodeAudioStream);
            break;
        }

        case Xs::game_chat_2::game_chat_stream_state_change_type::pre_encode_audio_stream_destroyed:
        {
            HandlePreEncodeAudioStreamDestroyed(streamStateChanges[streamStateChangeIndex].preEncodeAudioStream);
            break;
        }

        ...
    }
}
chat_manager::singleton_instance().finish_processing_stream_state_changes(streamStateChanges);

uint32_t preEncodeAudioStreamCount;
pre_encode_audio_stream_array preEncodeAudioStreams;
chat_manager::singleton_instance().get_pre_encode_audio_streams(&preEncodeAudioStreamCount, &preEncodeAudioStreams);
for (uint32_t preEncodeAudioStreamIndex = 0; preEncodeAudioStreamIndex < preEncodeAudioStreamCount; ++preEncodeAudioStreamIndex)
{
    pre_encode_audio_stream* stream = preEncodeAudioStreams[preEncodeAudioStreamIndex];
    StreamContext* context = reinterpret_cast<StreamContext*>(stream->custom_stream_context());

    game_chat_audio_format audio_format = stream->get_pre_processed_format();

    uint32_t preProcessedBufferByteCount;
    void* preProcessedBuffer;
    stream->get_next_buffer(&preProcessedBufferByteCount, &preProcessedBuffer);

    while (preProcessedBuffer != nullptr)
    {
        void* processedBuffer = nullptr;
        switch (audio_format.bits_per_sample)
        {
            case 16:
            {
                assert (audio_format.sample_type == game_chat_sample_type::integer);
                processedBuffer = ManipulateChatBuffer<int16_t>(preProcessedBufferByteCount, preProcessedBuffer, context);
                break;
            }
            case 32:
            {
                switch (audio_format.sample_type)
                {
                    case game_chat_sample_type::integer:
                    {
                        processedBuffer = ManipulateChatBuffer<int32_t>(preProcessedBufferByteCount, preProcessedBuffer, context);
                        break;
                    }
                    case game_chat_sample_type::ieee_float:
                    {
                        processedBuffer = ManipulateChatBuffer<float>(preProcessedBufferByteCount, preProcessedBuffer, context);
                        break;
                    }
                    default:
                    {
                        assert(false);
                        break;
                    }
                }
                break;
            }
            default:
            {
                assert(false);
                break;
            }
        }
        // processedBuffer can be the same as preProcessedBuffer (in-place manipulation) or it can be a buffer of
        // memory not managed by GC2 (out-of-place manipulation).
        stream->submit_buffer(processedBuffer);
        // Only return buffers retrieved from GC2. Do not return foreign memory to return_buffer.
        stream->return_buffer(preProcessedBuffer);
        stream->get_next_buffer(&preProcessedBufferByteCount, &preProcessedBuffer);
    }
}

Sleep(audioProcessingPeriodInMilliseconds);
```

## Manipulating post-decode chat audio data

This feature is currently in development. Calling into the post-decode audio manipulation interface will cause failures.

## Chat user lifetimes

Enabling real-time audio manipulation will affect the lifetimes of chat users. If `chat_manager::remove_user(chatUserX)` is called, the chat_user object pointed to by chatUserX will remain valid until all audio streams that reference chatUserX have been destroyed. Consider the following scenario:

```cpp
// At somepoint a chat user, chatUserX, leaves the game session.
chat_manager::singleton_instance().remove_user(chatUserX);

// chatUserX is still valid, but to avoid further synchronization, prevent non-audio-stream use of chatUserX
chatUserX = nullptr;

// On the audio processing thread...
uint32_t streamStateChangeCount;
game_chat_stream_state_change_array streamStateChanges;
chat_manager::singleton_instance().start_processing_stream_state_changes(&streamStateChangeCount, &streamStateChanges);
for (uint32_t streamStateChangeIndex = 0; streamStateChangeIndex < streamStateChangeCount; ++streamStateChangeIndex)
{
    switch (streamStateChanges[streamStateChangeIndex]->state_change_type)
    {
        ...

        // All of the streams associated with chatUserX will close.
        case Xs::game_chat_2::game_chat_stream_state_change_type::pre_encode_audio_stream_closed:
        {
            CleanupPreEncodeAudioStreamResources(streamStateChanges[streamStateChangeIndex].preEncodeAudioStream);
            break;
        }

        ...
    }
}
chat_manager::singleton_instance().finish_processing_stream_state_changes(streamStateChanges);

// The next time the app processes stream state changes...
uint32_t streamStateChangeCount;
game_chat_stream_state_change_array streamStateChanges;
chat_manager::singleton_instance().start_processing_stream_state_changes(&streamStateChangeCount, &streamStateChanges);
for (uint32_t streamStateChangeIndex = 0; streamStateChangeIndex < streamStateChangeCount; ++streamStateChangeIndex)
{
    switch (streamStateChanges[streamStateChangeIndex]->state_change_type)
    {
        ...

        case Xs::game_chat_2::game_chat_stream_state_change_type::pre_encode_audio_stream_destroyed:
        {
            uint32_t chatUserCount;
            Xs::game_chat_2::chat_user_array chatUsers;
            streamStateChanges[streamStateChangeIndex].preEncodeAudioStream->get_users(&chatUserCount, &chatUsers);
            assert(chatUserCount != 0);
            for (uint32_t chatUserIndex = 0; chatUserIndex < chatUserCount; ++chatUserIndex)
            {
                // chat_user objects such as chatUserX will still be valid while the destroyed state change is being processed.
                Log(chatUsers[chatUserIndex]->xbox_user_id());
            }
            break;
        }

        ...
    }
}
chat_manager::singleton_instance().finish_processing_stream_state_changes(streamStateChanges);
// Once the all destroyed state changes have been processed for all streams associated with chatUserX, it's memory will be invalidated.
// Do not call methods on chatUserX, e.g. chatUserX->xbox_user_id()
```
