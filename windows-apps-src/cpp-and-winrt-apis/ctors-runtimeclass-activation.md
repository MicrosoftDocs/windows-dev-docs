---
author: stevewhims
description: This topic describes essential concepts and terms that support your understanding of how to consume and author runtime classes with C++/WinRT.
title: Implementation and projected types for a C++/WinRT runtime class
ms.author: stwhi
ms.date: 03/05/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp, standard, c++, cpp, winrt, projected, projection, implementation, runtime class, activation
ms.localizationpriority: medium
---

# Implementation and projected types for a C++/WinRT runtime class
> [!NOTE]
> **Some information relates to pre-released product which may be substantially modified before itâ€™s commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here.**

This topic describes essential concepts and terms that support your understanding of how to consume and author runtime classes with C++/WinRT.

## Concepts and terminology
Let's introduce an example project so that we have a context in which to put these important concepts and terms. Imagine that your project name (and therefore your root namespace name) is MyProject. We recommend that you declare each runtime class in its own Interface Definition Language (IDL) (`.idl`) file. Here's an example.

```idl
// MyRuntimeClass.idl
namespace MyProject
{
	runtimeclass MyRuntimeClass
	{
		MyRuntimeClass(); // Declaring a constructor (or constructors) in the IDL causes the runtime class to be activatable from outside the compilation unit.
		String Name;
	}
}
```

This IDL declares a Windows Runtime (runtime) class. A runtime class is a type that can be activated and consumed via modern COM interfaces, typically across executable boundaries (but a runtime class can also be used within the compilation unit that implements it). From this IDL, the C++/WinRT toolchain generates an implementation type and a projected type, which are described in the summary below. An important point to take away from this summary is that saying only "**MyRuntimeClass**" may be ambiguous; there are several entities with that name, of different kinds.

- **MyRuntimeClass** is the name of a runtime class, declared in IDL.
- **MyRuntimeClass** is also the name of the C++ struct **winrt::MyProject::implementation::MyRuntimeClass**, which is the C++ implementation of the runtime class. If there are separate implementing and consuming projects, then this struct exists only in the implementing project. We'll call this type *the implementation type*, or *the implementation*. This type is generated by the `cppwinrt.exe` tool in `\MyProject\MyProject\Generated Files\sources\MyRuntimeClass.h` and `MyRuntimeClass.cpp`.
- **MyRuntimeClass** is also the name of the projected type (that is, a wrapper over the runtime class for consumption purposes) in the form of the C++ struct **winrt::MyProject::MyRuntimeClass**. If there are separate implementing and consuming projects, then this struct exists in both. We'll call this type *the projected type*, or *the projection*. This type is generated by `cppwinrt.exe` in `\MyProject\MyProject\Generated Files\winrt\impl\MyProject.2.h`.

The implementation type looks like this. 

```cppwinrt
// MyRuntimeClass.h
...
namespace winrt::MyProject::implementation
{
	struct MyRuntimeClass : MyRuntimeClassT<MyRuntimeClass>
	{
		MyRuntimeClass() = default;

		hstring Name();
		void Name(hstring const& value);
	};
}

// winrt::MyProject::factory_implementation::MyRuntimeClass is here, too.
```

Note the F-bound polymorphism pattern being used (**MyRuntimeClass** uses itself as a template argument to its base, **MyRuntimeClassT**). This is also called the curiously recurring template pattern (CRTP). If you follow the inheritance chain upwards, you'll come across **MyRuntimeClass_base**.

```cppwinrt
template <typename D, typename... I>
struct MyRuntimeClass_base : implements<D, MyProject::IMyRuntimeClass, I...>
```

And there we see the **implements** base struct template in action, as described in [Interfaces; how to implement them in C++/WinRT](implement-an-interface.md).

So much for the implementation type; let's now turn to the projected type. Here are the parts of the projected type that are relevant to this topic.

```cppwinrt
// MyProject.2.h
...
namespace winrt::MyProject
{
	struct MyRuntimeClass : MyProject::IMyRuntimeClass
	{
		MyRuntimeClass(std::nullptr_t) noexcept {}
		MyRuntimeClass();
	};
}
```

Here are some points to take away from the listings above.

- Each constructor you declare in your IDL causes a constructor to be generated on both your implementation type and on your projected type. IDL-declared constructors are used to consume the runtime class from *a different* compilation unit.
- Whether you have IDL-declared constructor(s) or not, a constructor overload that takes `nullptr` is generated on your projected type. The `nullptr` constructor is *one of the steps* in consuming the runtime class from *the same* compilation unit. We'll say more about this later.
- If you're consuming the runtime class from *the same* compilation unit, then you can also implement non-default constructors directly on the implementation type (which, remember, is in `MyRuntimeClass.h`).

Later in this topic we'll say more about how to use these constructors, and we'll link to other topics with even more details about specific use cases.

> [!NOTE]
> If you want to consume your runtime class from a different compilation unit (which is common), then include constructor(s) in your IDL (at least a default constructor). By doing that, you'll also get a factory implementation alongside your implementation type.
> 
> If you want to author and consume your runtime class only within the same 
compilation unit, then don't declare any constructor(s) in your IDL. You don't need a factory implementation, and one won't be generated. Your implementation type's default constructor will be deleted, but you can easily edit it and default it instead.
> 
> If you want to author and consume your runtime class only within the same 
compilation unit, and you need constructor parameters, then author the constructor(s) that you need directly on your implemenatation type.

## Consuming a runtime class that's in a Windows namespace
This is the most common case in which you'll consume a runtime class. Here's a simple code example.

```cppwinrt
#include "winrt/Windows.Foundation.h"

using namespace winrt;
using namespace Windows::Foundation;

int main()
{
	init_apartment();

	Uri contosoUri{ L"http://www.contoso.com" };
}
```

We include the header `winrt/Windows.Foundation.h`, which contains the projected type for the runtime class [**Windows::Foundation::Uri**](/uwp/api/windows.foundation.uri). And we construct the projected type via one of its publicly documented constructors ([**Uri(String)**](/uwp/api/windows.foundation.uri#Windows_Foundation_Uri__ctor_System_String_), in this example). The publicly documented constructors are the IDL-defined constructors. For this, the most common use case, that's all we have to do.

## Consuming a third-party runtime class
The next most common use case is consuming a third-party WinRT API.

If a third-party runtime class is implemented in a Windows Runtime Component and consumed from an app, then the implementation type and the consuming code are in different compilation units. In that case, the runtime class needs to be registered, and instantiated via WinRT/COM activation. You use `cppwinrt.exe` to generate a projected type from the component's Windows Metadata (`.winmd`). Then, just like with a Windows runtime class, you include a header and construct the projected type via one of its IDL-defined constructors (*not* the `nullptr` constructor). The consuming project's startup code registers the runtime class, and the projected type's constructor calls [**RoActivateInstance**](https://msdn.microsoft.com/library/br224646) to activate the runtime class from the referenced Windows Runtime component. For more details, code, and a walkthrough, see [Events; how to author and handle them in C++/WinRT](events-author-handle.md#create-a-core-app-bankaccountcoreapp-to-test-the-windows-runtime-component).

A third-party runtime class implemented in the same project as the consuming code doesn't need to be registered, nor instantiated via WinRT/COM activation. For this case, you use `cppwinrt.exe` to generate a projected type from the runtime class's Windows Metadata (`.winmd`). Then, you include a header and construct the projected type via its `nullptr` constructor. That constructor doesn't perform any initialization, so you must next assign a value to the instance via the [**winrt::make**](/uwp/cpp-ref-for-winrt/make) helper function, passing any necessary constructor arguments. For more details, code, and a walkthrough, see [XAML controls; binding to a C++/WinRT property](binding-property.md#add-a-property-of-type-bookstoreviewmodel-to-mainpage).

## Authoring a third-party runtime class
For details, code, and a walkthrough of authoring a third-party runtime class in a Windows Runtime Component, [Events; how to author and handle them in C++/WinRT](events-author-handle.md).

For details, code, and a walkthrough of authoring a third-party runtime class in an app project, see [XAML controls; binding to a C++/WinRT property](binding-property.md).

If you're authoring a runtime class then, from within the same compilation unit, you can use the [**winrt::make_self**](/uwp/cpp-ref-for-winrt/make-self) function  to construct an instance of the implementation type for the runtime class.

### Deriving from a type that has a non-trivial constructor
[**ToggleButtonAutomationPeer::ToggleButtonAutomationPeer(ToggleButton)**](/uwp/api/windows.ui.xaml.automation.peers.togglebuttonautomationpeer.-ctor#Windows_UI_Xaml_Automation_Peers_ToggleButtonAutomationPeer__ctor_Windows_UI_Xaml_Controls_Primitives_ToggleButton_) is an example of a non-trivial constructor. There's no default constructor so, to construct a **ToggleButtonAutomationPeer**, you need to pass an *owner*. Consequently, if you derive from **ToggleButtonAutomationPeer**, then you need to provide a constructor that takes an *owner* and passes it to the base. Let's see what that looks like in practice.

```idl
// MySpecializedToggleButton.idl
namespace MyNamespace
{
	runtimeclass MySpecializedToggleButton : Windows.UI.Xaml.Controls.Primitives.ToggleButton
	{
		...
	};
}
```

```idl
// MySpecializedToggleButtonAutomationPeer.idl
namespace MyNamespace
{
	runtimeclass MySpecializedToggleButtonAutomationPeer : Windows.UI.Xaml.Automation.Peers.ToggleButtonAutomationPeer
	{
		MySpecializedToggleButtonAutomationPeer(MySpecializedToggleButton owner);
	};
}
```

The generated constructor for your implementation type looks like this.

```cppwinrt
// MySpecializedToggleButtonAutomationPeer.cpp
...
MySpecializedToggleButtonAutomationPeer::MySpecializedToggleButtonAutomationPeer(MyNamespace::MySpecializedToggleButton const& owner)
{
	...
}
...
```

The only piece missing is that you need to pass that constructor parameter on to the base class. Remember the F-bound polymorphism pattern that we mentioned above? Once you're familiar with the details of that pattern as used by C++/WinRT, you can figure out what your base class is called (or you can just look in your implementation class's header file). This is how to call the base class constructor in this case.

```cppwinrt
// MySpecializedToggleButtonAutomationPeer.cpp
...
MySpecializedToggleButtonAutomationPeer::MySpecializedToggleButtonAutomationPeer(MyNamespace::MySpecializedToggleButton const& owner) : MySpecializedToggleButtonAutomationPeerT<MySpecializedToggleButtonAutomationPeer>(owner)
{
	...
}
...
```

The base class constructor expects a **ToggleButton**. And **MySpecializedToggleButton** *is a* **ToggleButton**.

Until you make the edit described above (to pass that constructor parameter on to the base class), the compiler will flag your constructor and point out that there's no appropriate default constructor available on a type called (in this case) **MySpecializedToggleButtonAutomationPeer_base&lt;MySpecializedToggleButtonAutomationPeer&gt;**. That's actually the base class of the bass class of your implementation type.

## Important APIs
* [winrt::make](/uwp/cpp-ref-for-winrt/make)
* [winrt::make_self](/uwp/cpp-ref-for-winrt/make-self)
